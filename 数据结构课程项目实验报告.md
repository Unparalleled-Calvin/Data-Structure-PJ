# 项目报告

##### 姓名：崔晨昊     学号：19307130084

### 项目概述

本项目要求设计一个合理的数据结构用以支持deque的一些基础操作。我采用红黑树的设计思想，用红黑树构造了一个“线性表”。并就第一个版本，尝试了两个优化方向，得到了两种不同性能的分支。

除基础功能外，目前实现了批量构造、迭代器(包括常量)构造、数组构造、复制构造、移动构造、析构、随机访问迭代器、begin、end迭代器成员、批量首尾插入删除、任意位置增删、range-based for。

### 基本设计

在写红黑树之前，我自行学习了一下stl实现deque的方法。一方面觉得deque虽然随机访问和表头表尾增删很快，但是中间插入和删除的效率很低。它的适用性不是很强。另一方面，很久之前就听说过stl的map、linux系统都是使用了红黑树的数据结构，所以也想就这个机会挑战一下自己。

红黑树是一棵不严格的平衡树，保证根节点到各个叶子结点经过的黑色结点相等，从而使得不同分支的树高比例不超过两倍。另外，相比于平衡树，红黑树的旋转操作要略少一点。

为了使该数据结构尽可能地标准和规范，我引入了三个类：node、RBT_iter、RBT，分别代表结点、迭代器以及树。node是原子结点，存储了父亲、两个子女、颜色、值、子树有效结点个数等信息。RBT_iter是经过封装的指针，支持一系列运算符操作。RBT中有begin、end、root三个比较重要的迭代器，随类中的方法动态的更新。

为RBT引入begin、end等迭代器之后，我随即按照中序遍历的顺序为迭代器写上了自增、自减操作符。另外，++除了自增为end，其余都会略去途中的哨兵结点。于是front()、back()、push_front()、push_back()等函数都非常自然地使用了迭代器以及insert、erase等方法。这里的insert以及erase在设计之初就已经计划好，要支持位置更加随机的插入删除。

insert函数具体的实现是先找到传入迭代器及向前第一个哨兵结点(一定能找到)。并用有效结点替换哨兵，连上左右两个哨兵儿子，并调用ipolish进行树结构的调整。在调整时，每当遇到左旋右旋的情况都更新一次母结点的num属性，即子数有效结点个数。并在调整结构完毕时，再根据调整前存储的指针自下而上遍历至根让每个结点num+1。

erase的情况较为复杂，可以分为六种情况。各种情况不再细谈(个人觉得其中的递归调整很有趣，另外也理解了为何要设置黑色的哨兵结点)。同样也是先将要处理的结点变为NIL，再调用epolish调整树结构。不过考虑到中途左右旋转的问题，num先不要变。同样等结构调整完毕时，再自下而上num-1。

随机访问[]是从根节点向下，以类似二分查找的方式找到对应的结点。swap函数交换了一下迭代器和几个属性值。clear则是递归删除整棵树，留下一个哨兵结点作为根，析构函数则不留下这个哨兵结点。

在重载迭代器+、-、++、--操作符时，我也兼顾了边界情况，即++最多到end迭代器，--最多到begin迭代器。为了使+、-的效率能够尽可能优化，我想到并设置了这样的一个判断，当偏移量小于60时，用朴素一次一次++的方法，当偏移大于60时，先拿到新迭代器的index，并查找该index构造出一个新的迭代器。这样可以保证+、-的复杂度都在logn。

### 优化尝试

本次大作业我一共尝试了两个优化方向，在时间和空间两个单独的方向取得了一定的改进。

首先，我注意到，当数据量较大的时，我的结构在析构上花的时间要远大于构造的时间。我猜测这是由于递归操作而引起的时间浪费，另外，由于访问结点的方式是使用指针，在new和delete上也花了大量的时间，同时，访问cache的命中率也有所下降。

于是我想到的第一个方案是：开辟一整块内存pool，将指针转为数组的索引，用一个队列来记录当前可用的位置。new和delete分别用函数alloc、revert来实现。具体来说，alloc检测队列是否为空，非空弹出队列头元素，否则将数组扩容(仿照vector进行1.5或两倍扩容并将结点依次复制)。revert函数简单地将索引号压进队列。

经过这样的优化，基础操作(1e7数量级)的时间从6500ms降至5500ms，约1/6。

然而在测试批量增删的时候，我发现我的内存占用达到了恐怖的900Mb。于是，我希望能够尝试优化一下内存空间的使用。

针对第一种优化出现的空间占用太大的问题，我尝试定义了一个新的类POOL，并声明一个全局变量pool用以兼容第一个优化版本的代码。POOL类同样有alloc和revert的友元函数。不过在内存的使用策略上，我注意到，第一个版本在扩容时，用于复制的时间以及将可用元素压入队列的时间都随着数据规模的增大成指数级增长。于是，我在想，是否可以在数组的尾巴后面新增一块定长的数组，从而解决复制、压队列耗时过长的问题——这样不需要复制，队列的利用效率也得到了很大的提高。我便在POOL类中使用一个vector来存放每个定长数组的指针，并定义了[]操作符和alloc的操作，使得一元索引能与实际二元索引相互转化。

用第二个优化版本代码进行测试，基础操作的空间使用降到了8Mb，批量增删的空间使用降到了300Mb。但是让我没有想到的是，虽然批量删插的空间耗费节省了2/3，但是时间耗费却升到了7000ms，差不多是一二两个版本的2.5倍。我想，可能的时间浪费在：

- 由于pool是全局多个红黑树实例共用的，所以在删除时还是不能像第二个版本一样直接将一整块内容释放，免不了大量递归。
- 最主要的浪费，我想是在pool[index]这样的访问上，由于代码中充斥着大量的对结点的访问，而这里的[]经过类方法的重载以及每次调用均涉及速度较慢的除法运算，时间耗费颇大。

由此看来，我的第一个初始版本的红黑树在时空复杂度上是后两个优化版本的折中。而后两个版本的优化仅在特定的方向上有一定作用，使用起来还是有一定的局限性。

由于采用红黑树结构，随机访问、随机增删的复杂度均为logn。

批量增删、批量构造均是朴素实现。

### 收获与展望

如前文所述，我所写的红黑树，虽然它的随机删除是我效率为logn，但是在批量首尾删插上和较连续的容器相比，效率仍然显得很低下。这固然和它是树结构本身存在一定的关系，但是和其他几位同学写的红黑树相比，我的红黑树在时间和空间的花费上更多。一方面，可能我写的代码不够精简，还有很多可以优化的地方，另一方面，我为我的树添加了哨兵结点(NIL)，然而哨兵结点除了在删除时简化了情况的判断，有利于递归调整结构之外，实际上在空间分配回收、情况特判方面都花费了大量额外的代价(多了一倍)，而如果将哨兵结点抹去而仅保留”哨兵“的概念，将原有的涉及到NIL判断的地方转为对nullptr或是索引为-1的判断，不仅在时间上会大大减少，同时空间上也会大大优化。由于期末时间紧迫，脑海中有这个想法却没能有时间进行第四次优化，这是我在这次pj中的一次遗憾。

本次pj，我熟悉了红黑树的基本特征，插入删除的做法，并自主地完成并调试了所有代码。同时，在其他同学的介绍中，也学到了很多其他有趣的数据结构。不同的数据结构适用于不同的场景，当操作、数据量达到一定数量级时，时间空间资源的消耗会有明显的提升。在特定需求下，如何选择最好性能的结构，这是我们应该要仔细考虑的。

### 测试数据

OJ ：base operation、batch push pop、for each test、alloc_test

聂绍珩的基础操作测试：https://www.luogu.com.cn/problem/U146001

### 参考资料

reference：

《图解红黑树及Java进行红黑二叉树遍历的方法》https://www.jb51.net/article/84833.htm
《红黑树（二）：删除》https://zhuanlan.zhihu.com/p/25402654